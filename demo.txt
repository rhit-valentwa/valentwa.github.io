#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
Baxter demo (single file):
1) Sweep every joint of the left arm
2) Animate a cartoon face on the head display (mouth opens/closes)
3) Turn the head (left, then center)
4) Sweep every joint of the right arm

Requirements
-----------
- ROS + Baxter SDK environment (baxter_interface)
- OpenCV (cv2) + cv_bridge
- Robot enabled (this script will enable/disable if needed)

Usage
-----
rosrun <your_pkg> baxter_demo_face_arms.py
(or: python baxter_demo_face_arms.py)

Safety
------
- Clear the workspace.
- Motion ranges are conservative, but you are responsible for safety.
"""

import math
import time
import rospy
import cv2
import numpy as np

from sensor_msgs.msg import Image
from cv_bridge import CvBridge
import baxter_interface
from baxter_interface import CHECK_VERSION

# ---------- Tunables ----------
SPEED_SCALER = 0.4         # 0..1 scale for joint speed
SWEEP_DELAY = 0.5          # pause at sweep endpoints (s)
JOINT_MOVE_TIMEOUT = 7.0   # seconds allowed per joint motion command
HEAD_PAN_LEFT = 0.7        # radians (left)
HEAD_PAN_CENTER = 0.0      # radians

# Conservative per-joint deltas (radians). Keys must match Baxter joint names.
DELTA_DEFAULT = 0.5
DELTA_OVERRIDES = {
    'left_e0':  0.8, 'left_e1': 0.6, 'left_w0': 0.8, 'left_w1': 0.6, 'left_w2': 0.8,
    'right_e0': 0.8, 'right_e1': 0.6, 'right_w0':0.8, 'right_w1':0.6, 'right_w2':0.8,
}
# Very conservative clamps (comfort range—adjust if you know your limits)
CLAMP_MIN = -1.7
CLAMP_MAX =  1.7

# Head display (Baxter LCD is 1024x600; image must be BGRA)
DISPLAY_W, DISPLAY_H = 1024, 600

# Face animation settings
CIRCLE_RADIUS = 60  # not used now; kept for easy swaps
ANIM_PAUSE = 0.02   # seconds between frames

def clamp(v, lo, hi):
    return max(lo, min(hi, v))

def sweep_joint(limb, joint_name):
    """Sweep a single joint left/right around its current position."""
    current = limb.joint_angle(joint_name)
    delta = DELTA_OVERRIDES.get(joint_name, DELTA_DEFAULT)
    target_lo = clamp(current - delta, CLAMP_MIN, CLAMP_MAX)
    target_hi = clamp(current + delta, CLAMP_MIN, CLAMP_MAX)

    limb.set_joint_position_speed(SPEED_SCALER)

    # Move to low
    limb.move_to_joint_positions({joint_name: target_lo}, timeout=JOINT_MOVE_TIMEOUT)
    rospy.sleep(SWEEP_DELAY)
    # Move to high
    limb.move_to_joint_positions({joint_name: target_hi}, timeout=JOINT_MOVE_TIMEOUT)
    rospy.sleep(SWEEP_DELAY)
    # Return to start
    limb.move_to_joint_positions({joint_name: current}, timeout=JOINT_MOVE_TIMEOUT)

def sweep_all_joints(limb_name):
    limb = baxter_interface.Limb(limb_name)
    rospy.loginfo("Sweeping joints on %s arm...", limb_name)
    for j in limb.joint_names():
        rospy.loginfo("  Sweeping joint: %s", j)
        sweep_joint(limb, j)

def animate_face_on_head():
    """
    Draw a face (eyes + head outline) on Baxter's display and animate the mouth
    opening and closing. Publishes BGRA images to /robot/xdisplay.
    """
    pub = rospy.Publisher('/robot/xdisplay', Image, queue_size=1)
    bridge = CvBridge()

    # Wait briefly for subscriber (the head display)
    start = time.time()
    while pub.get_num_connections() == 0 and (time.time() - start) < 3.0 and not rospy.is_shutdown():
        rospy.sleep(0.05)

    # ---- Face layout (in pixels) ----
    W, H = DISPLAY_W, DISPLAY_H                 # 1024x600 by default
    cx, cy = W // 2, H // 2 + 10               # face center
    face_radius = min(W, H) // 3               # head outline

    # Eyes
    eye_offset_x = int(face_radius * 0.55)
    eye_offset_y = int(face_radius * -0.2)
    eye_radius   = int(face_radius * 0.10)

    # Mouth
    mouth_width  = int(face_radius * 0.95)
    mouth_y      = cy + int(face_radius * 0.45)
    mouth_min_h  = max(6, int(face_radius * 0.02))   # nearly closed
    mouth_max_h  = int(face_radius * 0.30)           # wide open

    # Animation pacing
    cycles = 2                       # how many open→close cycles
    steps_per_half = 30              # frames to go closed→open (and back)
    pause = ANIM_PAUSE               # seconds between frames

    def draw_frame(mouth_h):
        # White background
        img = np.ones((H, W, 3), dtype=np.uint8) * 255

        # Head outline
        cv2.circle(img, (cx, cy), face_radius, (0, 0, 0), thickness=8, lineType=cv2.LINE_AA)

        # Eyes
        left_eye  = (cx - eye_offset_x, cy + eye_offset_y)
        right_eye = (cx + eye_offset_x, cy + eye_offset_y)
        cv2.circle(img, left_eye,  eye_radius, (0, 0, 0), thickness=-1, lineType=cv2.LINE_AA)
        cv2.circle(img, right_eye, eye_radius, (0, 0, 0), thickness=-1, lineType=cv2.LINE_AA)

        # Mouth: filled ellipse (rounded rectangle look)
        mouth_rect_center = (cx, mouth_y)
        mouth_axes = (mouth_width // 2, max(10, mouth_h) // 2)  # (half-width, half-height)
        cv2.ellipse(img, mouth_rect_center, mouth_axes, 0, 0, 360, (0, 0, 0),
                    thickness=-1, lineType=cv2.LINE_AA)

        # Convert BGR -> BGRA
        return cv2.cvtColor(img, cv2.COLOR_BGR2BGRA)

    # Build animation sequence: closed -> open -> closed (sinusoidal ease)
    def seq():
        # up (open)
        for i in range(steps_per_half):
            t = (i + 1) / float(steps_per_half)
            s = 0.5 - 0.5 * math.cos(math.pi * t)  # 0..1 eased
            yield int(mouth_min_h + s * (mouth_max_h - mouth_min_h))
        # down (close)
        for i in range(steps_per_half):
            t = (i + 1) / float(steps_per_half)
            s = 0.5 - 0.5 * math.cos(math.pi * t)
            yield int(mouth_max_h - s * (mouth_max_h - mouth_min_h))

    rospy.loginfo("Animating face (mouth open/close) on head display...")
    for _ in range(cycles):
        for mh in seq():
            if rospy.is_shutdown():
                return
            frame = draw_frame(mh)
            msg = bridge.cv2_to_imgmsg(frame, encoding="bgra8")
            pub.publish(msg)
            rospy.sleep(pause)

def turn_head(pan_rad):
    head = baxter_interface.Head()
    try:
        head.set_pan(pan_rad, speed=0.3, timeout=3.0)
    except TypeError:
        # Older SDK signature may be set_pan(pan, speed=..)
        head.set_pan(pan_rad, speed=0.3)
    rospy.sleep(0.5)

def main():
    rospy.init_node("baxter_demo_face_arms")

    # Enable robot if needed
    rs = baxter_interface.RobotEnable(CHECK_VERSION)
    was_enabled = rs.state().enabled
    if not was_enabled:
        rospy.loginfo("Enabling robot...")
        rs.enable()

    try:
        # 1) Left arm sweeps
        sweep_all_joints('left')

        # 2) Face animation on head display
        animate_face_on_head()

        # 3) Head turn left, then center
        rospy.loginfo("Turning head left, then center...")
        turn_head(HEAD_PAN_LEFT)
        rospy.sleep(0.6)
        turn_head(HEAD_PAN_CENTER)

        # 4) Right arm sweeps
        sweep_all_joints('right')

    finally:
        # Return robot to prior enabled state
        if not was_enabled:
            rospy.loginfo("Disabling robot (returning to prior state)...")
            rs.disable()

    rospy.loginfo("Done.")

if __name__ == "__main__":
    main()
